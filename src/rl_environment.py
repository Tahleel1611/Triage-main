import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pandas as pd
import os

class EDTriageEnv(gym.Env):
    """
    A custom Gymnasium environment for Emergency Department Triage Optimization.
    
    This environment simulates the decision-making process of a Triage Coordinator.
    It uses the predictions from the Phase 4 Hybrid Model as part of the state.
    
    UPDATED: Includes Resource Constraints Simulation (Bed Occupancy).
    """
    
    def __init__(self):
        super(EDTriageEnv, self).__init__()
        
        # --- Action Space ---
        # 0: Waiting Room
        # 1: Fast Track
        # 2: Acute Care Bed
        # 3: Critical Care
        # 4: Order Diagnostics (Wait)
        self.action_space = spaces.Discrete(5)
        
        # --- Observation Space ---
        # [Patient_Probs(5), Deterioration(1), Embeddings(10), ED_Occupancy(4), Time(2)]
        # ED_Occupancy: [Waiting_Count, Critical_Occ, Acute_Occ, FastTrack_Occ] (Normalized)
        # Total dims = 5 + 1 + 10 + 4 + 2 = 22
        
        low = np.array([0.0]*22, dtype=np.float32)
        high = np.array([np.inf]*22, dtype=np.float32) # Use Inf for safety, though most are 0-1
        
        self.observation_space = spaces.Box(low=low, high=high, dtype=np.float32)
        
        # --- Resource Capacities ---
        self.MAX_CRITICAL = 10
        self.MAX_ACUTE = 30
        self.MAX_FAST = 20
        
        # Simulation State
        self.current_patient_idx = 0
        self.patients_df = self._load_patient_data()
        self.num_patients = len(self.patients_df)
        
        self.state = {
            'waiting': 0,
            'occ_critical': 0,
            'occ_acute': 0,
            'occ_fast': 0
        }
        
    def _load_patient_data(self):
        """
        Loads the RL-ready data generated by the Hybrid Model.
        """
        paths = [
            "data/rl_ready_data_nhamcs.csv",
            "../data/rl_ready_data_nhamcs.csv",
            "data/rl_ready_data.csv"
        ]
        
        for p in paths:
            if os.path.exists(p):
                try:
                    return pd.read_csv(p)
                except:
                    continue
                    
        print("Warning: No data found. Using mock data.")
        return pd.DataFrame()

    def reset(self, seed=None, options=None):
        """
        Resets the environment to the start of a shift.
        """
        super().reset(seed=seed)
        
        # Reset ED State (Start empty or partially full)
        self.state = {
            'waiting': np.random.randint(0, 5),
            'occ_critical': np.random.randint(0, 5),
            'occ_acute': np.random.randint(0, 10),
            'occ_fast': np.random.randint(0, 5)
        }
        
        # Reset Patient Iterator
        if self.num_patients > 0:
            self.current_patient_idx = np.random.randint(0, self.num_patients)
            self.current_patient = self._get_next_patient()
        else:
            self.current_patient = self._get_mock_patient()
        
        observation = self._get_observation()
        info = {}
        return observation, info
    
    def step(self, action):
        """
        Execute one time step within the environment.
        """
        reward = 0
        terminated = False
        truncated = False
        info = {}
        
        # --- 1. Simulate Hospital Dynamics (Discharge) ---
        # Patients leave beds randomly (simulating treatment completion)
        if self.state['occ_critical'] > 0 and np.random.random() < 0.05: # Slow turnover
            self.state['occ_critical'] -= 1
        if self.state['occ_acute'] > 0 and np.random.random() < 0.10: # Medium turnover
            self.state['occ_acute'] -= 1
        if self.state['occ_fast'] > 0 and np.random.random() < 0.20: # Fast turnover
            self.state['occ_fast'] -= 1
            
        # --- 2. Apply Action & Calculate Reward ---
        patient_acuity = self.current_patient['acuity'] # 1 (Critical) to 5 (Non-urgent)
        
        # Action 0: Waiting Room
        if action == 0: 
            self.state['waiting'] += 1
            if patient_acuity <= 2:
                reward -= 500 # CRITICAL SAFETY PENALTY (ESI 1/2 waiting)
            else:
                reward -= 1 # Minor wait penalty
                
        # Action 3: Critical Care
        elif action == 3: 
            # Check Capacity
            if self.state['occ_critical'] < self.MAX_CRITICAL:
                self.state['occ_critical'] += 1
                # Triage Logic
                if patient_acuity >= 4:
                    reward -= 20 # Resource Waste (ESI 4/5 in Critical)
                else:
                    reward += 20 # Good catch
            else:
                # Overcrowding Decision
                self.state['occ_critical'] += 1
                reward -= 50 # Overcrowding Penalty
                # Still evaluate triage correctness
                if patient_acuity >= 4: reward -= 20
                else: reward += 20

        # Action 1: Fast Track
        elif action == 1: 
            if self.state['occ_fast'] < self.MAX_FAST:
                self.state['occ_fast'] += 1
                if patient_acuity >= 4: 
                    reward += 15 # Perfect for ESI 4/5
                else: 
                    reward -= 500 # CRITICAL SAFETY PENALTY (Under-triage)
            else:
                # Overcrowding
                self.state['occ_fast'] += 1
                reward -= 30 # Overcrowding Penalty (less severe than Critical)
                if patient_acuity >= 4: reward += 15
                else: reward -= 500

        # Action 2: Acute Care Bed
        elif action == 2: 
            if self.state['occ_acute'] < self.MAX_ACUTE:
                self.state['occ_acute'] += 1
                if patient_acuity == 2 or patient_acuity == 3:
                    reward += 15 # Correct allocation
                elif patient_acuity == 1:
                    reward -= 500 # CRITICAL SAFETY PENALTY (Should be Critical)
                else: 
                    reward -= 10 # Resource waste
            else:
                # Overcrowding
                self.state['occ_acute'] += 1
                reward -= 40 # Overcrowding Penalty
                if patient_acuity in [2, 3]: reward += 15
                elif patient_acuity == 1: reward -= 500
                else: reward -= 10

        # Action 4: Order Diagnostics (Wait)
        elif action == 4: 
            reward -= 5 # Cost/Time penalty
            self.state['waiting'] += 1

        # --- 3. Advance Simulation ---
        if self.num_patients > 0:
            self.current_patient_idx = (self.current_patient_idx + 1) % self.num_patients
            self.current_patient = self._get_next_patient()
        else:
            self.current_patient = self._get_mock_patient()
            
        observation = self._get_observation()
        
        return observation, reward, terminated, truncated, info
    
    def _get_next_patient(self):
        """Fetches the next patient from the dataset."""
        row = self.patients_df.iloc[self.current_patient_idx]
        
        # Extract probs
        prob_cols = [c for c in self.patients_df.columns if 'prob_class_' in c]
        if not prob_cols:
             # Fallback if columns missing
             probs = np.array([0.2]*5)
        else:
            probs = row[prob_cols].values.astype(float)
        
        if len(probs) < 5:
            probs = np.pad(probs, (0, 5 - len(probs)))
            
        # Get risk
        risk = row['risk'] if 'risk' in row else 0.5
        
        # Get acuity
        acuity = row['ESI'] if 'ESI' in row else 3

        return {
            'probs': probs,
            'risk': float(risk),
            'embedding': np.zeros(10), # Placeholder
            'acuity': acuity
        }

    def _get_mock_patient(self):
        return {
            'probs': np.array([0.2]*5),
            'risk': 0.5,
            'embedding': np.zeros(10),
            'acuity': 3
        }

    def _get_observation(self):
        """
        Constructs the state vector.
        """
        # 1. Patient Features
        probs = self.current_patient['probs'] # (5,)
        risk = [self.current_patient['risk']] # (1,)
        embedding = self.current_patient['embedding'] # (10,)
        
        # 2. ED State (Normalized by Capacity)
        # We use occupancy ratio to make it generalizable
        occ_state = [
            self.state['waiting'] / 50.0, # Normalize waiting room (assume 50 is "full")
            self.state['occ_critical'] / self.MAX_CRITICAL,
            self.state['occ_acute'] / self.MAX_ACUTE,
            self.state['occ_fast'] / self.MAX_FAST
        ]
        
        # 3. Time (Mock)
        time_feat = [0.5, 0.5] # Placeholder
        
        obs = np.concatenate([probs, risk, embedding, occ_state, time_feat])
        return obs.astype(np.float32)
